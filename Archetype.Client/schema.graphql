schema {
  query: Queries
  mutation: Mutations
  subscription: Subscriptions
}

"The root object of actionable game state"
type GameState implements IGameState {
  gamePiece(guid: UUID!): IGameAtom
  player: IPlayer
  map: IMap
}

"The player of the game"
type Player implements IPlayer & IGameAtom {
  mill(strength: Int!): Int!
  draw(strength: Int!): Int!
  name: String
  maxHandSize: Int!
  minDeckSize: Int!
  resources: Int!
  deck: IDeck
  hand: IHand
  discardPile: IDiscardPile
  guid: UUID!
  owner: IGameAtom
}

"A graph of map nodes"
type Map implements IMap {
  nodes: [IMapNode]
}

"A node on the map"
type MapNode implements IMapNode & IGameAtom & IZoneOfIUnit {
  typedPiece(guid: UUID!): IUnit
  gamePiece(guid: UUID!): IGameAtom
  neighbours: [IMapNode]
  contents: [IUnit]
  guid: UUID!
  owner: IGameAtom
}

"Collection of all available card sets"
type CardPool implements ICardPool {
  cards: [ICardProtoData]
  sets: [ICardSet]
}

"A set of card proto data which share some themes"
type CardSet implements ICardSet {
  name: String
  cards: [ICardProtoData]
}

"A stack of cards which replenishes the player's hand"
type Deck implements IDeck & IGameAtom & IZoneOfICard {
  draw: ICard
  typedPiece(guid: UUID!): ICard
  gamePiece(guid: UUID!): IGameAtom
  contents: [ICard]
  guid: UUID!
  owner: IGameAtom
}

"A hand of cards, only visible to the owner"
type Hand implements IHand & IGameAtom & IZoneOfICard {
  typedPiece(guid: UUID!): ICard
  gamePiece(guid: UUID!): IGameAtom
  contents: [ICard]
  guid: UUID!
  owner: IGameAtom
}

"Discard pile, where spent cards go"
type DiscardPile implements IDiscardPile & IGameAtom & IZoneOfICard {
  typedPiece(guid: UUID!): ICard
  gamePiece(guid: UUID!): IGameAtom
  contents: [ICard]
  guid: UUID!
  owner: IGameAtom
}

"Blueprint for creating card instances"
type CardProtoData implements ICardProtoData {
  guid: UUID!
  rulesText: String
  cost: Int!
  metaData: CardMetaData
  targets: [ITarget]
  effects: [IEffect]
}

"A unit instance"
type Unit implements IUnit & IGameAtom {
  attack(strength: Int!): Int!
  heal(strength: Int!): Int!
  protoGuid: UUID!
  deck: IDeck
  metaData: UnitMetaData
  maxHealth: Int!
  health: Int!
  currentZone: IZoneOfIUnit
  guid: UUID!
  owner: IGameAtom
}

"A card instance"
type Card implements ICard & IGameAtom {
  contextRulesText: String!
  rulesText: String!
  reduceCost(x: Int!): Int!
  cost: Int!
  protoGuid: UUID!
  metaData: CardMetaData
  targets: [ITarget]
  effects: [IEffect]
  currentZone: IZoneOfICard
  guid: UUID!
  owner: IGameAtom
}

"The target of a card"
type ITarget {
  typeId: String
}

"The core payload of a card, where mutation of game atoms happen"
type IEffect {
  targetIndex: Int!
}

interface IGameState {
  gamePiece(guid: UUID!): IGameAtom
  player: IPlayer
  map: IMap
}

interface IPlayer {
  mill(strength: Int!): Int!
  draw(strength: Int!): Int!
  name: String
  maxHandSize: Int!
  minDeckSize: Int!
  resources: Int!
  deck: IDeck
  hand: IHand
  discardPile: IDiscardPile
  guid: UUID!
  owner: IGameAtom
}

interface IMap {
  nodes: [IMapNode]
}

interface IMapNode {
  neighbours: [IMapNode]
  typedPiece(guid: UUID!): IUnit
  contents: [IUnit]
  guid: UUID!
  owner: IGameAtom
}

interface ICardPool {
  cards: [ICardProtoData]
  sets: [ICardSet]
}

interface ICardSet {
  name: String
  cards: [ICardProtoData]
}

interface IDeck {
  draw: ICard
  typedPiece(guid: UUID!): ICard
  contents: [ICard]
  guid: UUID!
  owner: IGameAtom
}

interface IHand {
  typedPiece(guid: UUID!): ICard
  contents: [ICard]
  guid: UUID!
  owner: IGameAtom
}

interface IDiscardPile {
  typedPiece(guid: UUID!): ICard
  contents: [ICard]
  guid: UUID!
  owner: IGameAtom
}

interface ICardProtoData {
  guid: UUID!
  rulesText: String
  cost: Int!
  metaData: CardMetaData
  targets: [ITarget]
  effects: [IEffect]
}

interface IUnit {
  attack(strength: Int!): Int!
  heal(strength: Int!): Int!
  protoGuid: UUID!
  deck: IDeck
  metaData: UnitMetaData
  maxHealth: Int!
  health: Int!
  guid: UUID!
  owner: IGameAtom
}

interface ICard {
  reduceCost(x: Int!): Int!
  protoGuid: UUID!
  metaData: CardMetaData
  cost: Int!
  targets: [ITarget]
  effects: [IEffect]
  guid: UUID!
  owner: IGameAtom
}

type Queries {
  gameState: IGameState!
  cardPool: ICardPool!
}

type Mutations {
  playCard(playCardInput: PlayCardInput!): PlayCardPayload!
  startGame(startGameInput: StartGameInput!): StartGamePayload!
  endTurn: TurnStartedPayload!
}

type Subscriptions {
  onCardPlayed: PlayCardPayload!
  onGameStarted: StartGamePayload!
  onTurnStarted: TurnStartedPayload!
}

interface IGameAtom {
  guid: UUID!
  owner: IGameAtom
}

scalar UUID

interface IZoneOfICard {
  typedPiece(guid: UUID!): ICard
  contents: [ICard]
  guid: UUID!
  owner: IGameAtom
}

type UnitMetaData {
  name: String
  imageUri: String
}

interface IZoneOfIUnit {
  typedPiece(guid: UUID!): IUnit
  contents: [IUnit]
  guid: UUID!
  owner: IGameAtom
}

type CardMetaData {
  name: String
  setName: String
  rarity: CardRarity!
  color: CardColor!
  imageUri: String
}

enum CardColor {
  WHITE
  BLUE
  BLACK
  RED
  GREEN
}

enum CardRarity {
  COMMON
  UNCOMMON
  RARE
  MYTHIC
}

type TurnStartedPayload {
  message: String!
}

input StartGameInput {
  protoCardIds: [UUID!]!
}

type StartGamePayload {
  message: String!
}

input PlayCardInput {
  cardId: UUID!
  targetIds: [UUID!]!
}

type PlayCardPayload {
  message: String!
}